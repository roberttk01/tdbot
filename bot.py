import discord
import openai
import random
import json
#import logging

# # Set up logging to see connection issues
# logging.basicConfig(level=logging.INFO)
## Testing Github Commit... one more time

# Load configuration from file
with open('config.json', 'r') as config_file:
    config = json.load(config_file)

# Set up intents
intents = discord.Intents.default()
intents.message_content = True

# Initialize the Discord client with intents
client = discord.Client(intents=intents)
openai.api_key = config['openai_api_key']

# Load truth and dare data
def load_data():
    with open('questions.json', 'r') as f:
        data = json.load(f)
    return data['truths'], data['dares']

truths, dares = load_data()

# Function to create the embed
def create_embed(user, title, description, question_type, question_id, value):
    # Truncate value to 1024 characters if it exceeds the limit
    if len(value) > 1024:
        value = value[:1021] + "..."  # Truncate and add ellipsis to indicate more content

    embed = discord.Embed(
        title=title,
        description=description,
        color=discord.Color.blue()
    )
    embed.add_field(name="ðŸ’¡ Question", value=value, inline=False)
    embed.set_footer(text=f"Type: {question_type} | ID: {question_id}")
    embed.set_author(name=f"Requested by {user.name}", icon_url=user.avatar.url)  # Use user for author
    return embed

# Function to create buttons
def create_buttons():
    buttons = discord.ui.View()
    buttons.add_item(discord.ui.Button(label="Truth", style=discord.ButtonStyle.success, custom_id="truth"))
    buttons.add_item(discord.ui.Button(label="Dare", style=discord.ButtonStyle.danger, custom_id="dare"))
    buttons.add_item(discord.ui.Button(label="GPTruth", style=discord.ButtonStyle.primary, custom_id="gptruth"))
    return buttons


@client.event
async def on_ready():
    print(f'We have logged in as {client.user}')

# Handle disconnection
# @client.event
# async def on_disconnect():
#     logging.warning(f"{client.user} has disconnected. Attempting to reconnect...")
#
# # Handle any errors that might occur during the bot's operation


# @client.event
# async def on_error(event, *args, **kwargs):
#     logging.error(f"Error occurred in event {event}: {args}, {kwargs}")
#     # You can also add specific error handling logic depending on the event

@client.event
async def on_message(message):
    if message.author == client.user:
        return

    # /loftruth Command
    if message.content.lower().startswith('/loftruth'):
        question = random.choice(truths)
        embed = create_embed(
            user=message.author,  # Pass the whole message object here
            title="Truth Question ðŸŽ­",
            description="Here's a truth question for you:",
            question_type="TRUTH",
            question_id="1234abcd",
            value=question
        )
        await message.channel.send(embed=embed, view=create_buttons())

    # /lofdare Command
    elif message.content.lower().startswith('/lofdare'):
        question = random.choice(dares)
        embed = create_embed(
            user=message.author,  # Pass the whole message object here
            title="Dare Challenge ðŸ”¥",
            description="Here's a dare challenge for you:",
            question_type="DARE",
            question_id="5678efgh",
            value=question
        )
        await message.channel.send(embed=embed, view=create_buttons())

    # /gptruth Command
    elif message.content.lower().startswith('/gptruth'):
        prompt = ("Generate a highly personal, fun, insightful truth question for a truth or dare game. "
                  "The question can be deep, funny, serious, risquÃ©, or thought-provoking, "
                  "but it must be original and engaging. Please output the question in English, French, "
                  "Spanish, Swedish, Ukrainian and Vietnamese")
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4o-mini",  # Ensure you have GPT-4 access
                messages=[{"role": "user", "content": prompt}]
            )
            gpt_response = response['choices'][0]['message']['content'].strip()

            embed = create_embed(
                user=message.author,  # Pass the whole message object here
                title="ðŸ¤– ChatGPT Truth",
                description="Here's a truth question generated by GPT:",
                question_type="GPT-TRUTH",
                question_id="9876ijkl",
                value=gpt_response
            )
            await message.channel.send(embed=embed, view=create_buttons())
        except Exception as e:
            await message.channel.send(f"Error: {str(e)}")


# Button Interaction Handling
@client.event
async def on_interaction(interaction):
    if interaction.type == discord.InteractionType.component:
        custom_id = interaction.data['custom_id']  # Correctly access the custom_id

        # Defer the interaction immediately to avoid timeout errors
        await interaction.response.defer(ephemeral=True)  # This tells Discord we're processing

        try:
            # Send a "Thinking..." message to inform the user we're generating the response
            thinking_message = await interaction.followup.send("ðŸ§  Thinking... Please wait while I generate a question!",
                                                               ephemeral=True)

            if custom_id == "truth":
                question = random.choice(truths)  # Get a random truth question
                embed = create_embed(
                    user=interaction.user,  # Pass the user object for author info
                    title=f"Requested by {interaction.user.name}",
                    description="Here's another truth question for you:",
                    question_type="TRUTH",
                    question_id="t75qcvn8j3w",  # You can use a dynamic ID if needed
                    value=question
                )
                await interaction.followup.send(embed=embed, view=create_buttons())

            elif custom_id == "dare":
                dare = random.choice(dares)  # Get a random dare
                embed = create_embed(
                    user=interaction.user,  # Pass the user object for author info
                    title=f"Requested by {interaction.user.name}",
                    description="Here's another dare challenge for you:",
                    question_type="DARE",
                    question_id="d45pocx7h1",  # You can use a dynamic ID if needed
                    value=dare
                )
                await interaction.followup.send(embed=embed, view=create_buttons())

            elif custom_id == "gptruth":
                # Generate a new truth question using GPT-4
                prompt = ("Generate a highly personal, fun, insightful truth question for a truth or dare game. "
                          "The question can be deep, funny, serious, risquÃ©, or thought-provoking, "
                          "but it must be original and engaging. Please output the question in English, French, "
                          "Spanish, Swedish, Ukrainian, and Vietnamese.")

                # Make the API request to OpenAI
                response = openai.ChatCompletion.create(
                    model="gpt-4o-mini",  # Ensure you have GPT-4 access
                    messages=[{"role": "user", "content": prompt}]
                )
                gpt_response = response['choices'][0]['message']['content'].strip()

                # Truncate the response if it's too long
                if len(gpt_response) > 1024:
                    gpt_response = gpt_response[:1021] + "..."  # Truncate and add ellipsis to indicate more content

                # Create embed using interaction.user for the author's details
                embed = create_embed(
                    user=interaction.user,  # Pass the user object for author info
                    title="ðŸ¤– GPT Truth",
                    description="Here's a truth question generated by GPT-4:",
                    question_type="GPT-TRUTH",
                    question_id="9876ijkl",  # Generate or randomize an ID if needed
                    value=gpt_response
                )

                # Acknowledge the interaction and send the embed
                await interaction.followup.send(embed=embed, ephemeral=False, view=create_buttons())

            # Once the final response is sent, delete the "Thinking..." message
            await thinking_message.delete()

        except Exception as e:
            # Handle errors and acknowledge the interaction
            await interaction.followup.send(f"Error: {str(e)}", ephemeral=True)
            await thinking_message.delete()  # Delete the "Thinking..." message if there's an error


client.run(config['discord_token'])
